\documentclass{article}
% \usepackage[UTF8]{ctex}
\usepackage{color,amsmath,amssymb,graphicx,fancyhdr,amsfonts,amsthm,algorithmic,verbatim,bbold}
\usepackage{algorithm,hyperref}
\usepackage{mkolar_definitions}
\usepackage{extpfeil}
\usepackage{mathpartir}
\usepackage{wasysym}
\usepackage[mathscr]{eucal}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{relsize}
\usepackage[left=2cm,top=2cm,right=2cm]{geometry}
\numberwithin{algorithm}{section}

\newcommand{\doublebrackets}[1]{[\![ #1 ]\!]}
\newcommand{\progspec}[1]{\{ #1 \}}
\newcommand{\tuple}[1]{\langle #1 \rangle}

\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\cref}{\texttt{ref}}
\newcommand{\cfork}[1]{\texttt{fork}\{#1\}}
\newcommand{\cloop}[1]{\texttt{loop}_{#1}\,}
\newcommand{\cbreak}{\texttt{break}\,}
\newcommand{\ccontinue}{\texttt{continue}}
\newcommand{\cif}{\texttt{if}\,}
\newcommand{\cthen}{\,\texttt{then}\,}
\newcommand{\celse}{\,\texttt{else}\,}
\newcommand{\cseq}{\,;;\,}
\newcommand{\creturn}{\texttt{return}\,}
\newcommand{\ccall}{\texttt{call}\,}

\newcommand{\tunit}{\texttt{unit}}
\newcommand{\tint}{\texttt{int}}
\newcommand{\tbool}{\texttt{bool}}
\newcommand{\vtype}[1]{\textbf{V}[#1]}

\newcommand{\pure}[1]{\text{PenCtx}(#1)}
\newcommand{\wellf}[1]{\text{well\_formed}(#1)}

\newcommand{\hred}{\rightarrow_h}
\newcommand{\tred}{\rightarrow_t}
\newcommand{\tpred}{\rightarrow_{tp}}
\newcommand{\cred}{\text{red}}

\newcommand{\wand}{-\mkern-8mu*\,}
\newcommand{\upd}{\dot{|\mkern-8mu\Rrightarrow}\,}
\newcommand{\later}{\triangleright}
\newcommand{\wpre}[5]{\textsf{wp}\, #1\, \progspec{#2}\, \progspec{#3}\, \progspec{#4}\, \progspec{#5}}
\newcommand{\htriple}[6]{\progspec{#1}\, #2\, \progspec{#3}\, \progspec{#4}\, \progspec{#5}\, \progspec{#6}}

\newcommand{\sep}{\,|\,}

\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}

\begin{document}

\section{The Programming Language}

Below shows the syntax of the programming language we consider, which is an extension of the one in the original Iris paper.
We also take Rust language as a reference in the design of the language.
$$
\begin{aligned}
    v \in \textit{Val} ::=\, & () \sep z \sep \true \sep \false \sep l \sep \lambda x.e \sep \cdots \\
    e \in \textit{Expr} ::=\, & v \sep x \sep e_1(e_2) \sep \cref(e) \sep !e \sep e_1 \leftarrow e_2 \sep \cfork{e} \sep e_1 \cseq e_2 \sep \cloop{e} e \\
                        \sep\, & \cif e_1 \cthen e_2 \celse e_3 \sep \cbreak e \sep \ccontinue \sep \ccall e \sep \creturn e \sep \cdots \\
    K \in \textit{Ctx} ::=\, & \bullet \sep K(e) \sep v(K) \sep \cref(K) \sep !K \sep K \leftarrow e \sep v \leftarrow K \sep K \cseq e \sep \cloop{e} K \\
                        \sep\, & \cif K \cthen e_2 \celse e_3 \sep \cbreak K \sep \ccall K \sep \creturn K \sep \cdots
\end{aligned}
$$

To allow context binding, we use $\cloop{e} e$ to represent a loop statement with $e$ as its loop body.
$e$ serves as a parameter in the corresponding evaluation context for the loop command.
After the completion of evaluation for expression in $K$, we can still recover the complete loop body from the subscription of $\cloop{e}\!$.
We can wrap the conventional loop definition as $\texttt{loop}\, e \triangleq \cloop{e} e$.

The $\cbreak\!$ statement and $\ccontinue$ statement are scoped by $\cloop{e}\!$ and can only manipulate the control flow within the loop.
The sequence statement and if statement definitions are standard.

We also consider control flow related to function invocations.
To the resolve the problem of whether the $\creturn\!$ statement can penetrate unnamed functions defined with the $\lambda$ operator (e.g. which one of 1 and 2 should $(\lambda x. \creturn x)(1) \cseq 2$ evaluate to), we use $\ccall\!$ to scope the influence of $\creturn\!$.
We can still define recursive functions in lambda calculus with the $\creturn\!$ functioning properly.

\todo{Probabily an example}

% $\cbreak\!$ and $\ccontinue$ can not penetrate $\cloop{e}\!$, and $\creturn\!$ can not penetrate $\ccall\!$.
% A problem, $(\lambda x. \creturn x)(1) \cseq 3$ should evaluate to 1 or 3? In other words, whether the lambda expression is a function or a normal expression?

\section{Operational Semantics}

We then define the operational semantics of the language.
We mainly work on the head reduction ($\hred$), and the thread local reduction ($\tred$) and thread-pool reduction ($\tpred$) are identical to the original ones.

\begin{figure}[h]
$$
\begin{aligned}
    (\cloop{e} (), \sigma) &\hred (\cloop{e} e, \sigma, \epsilon) && \\
    (\cloop{e} (\ccontinue), \sigma) &\hred (\cloop{e} e, \sigma, \epsilon) &&  \\
    (\cloop{e} (\cbreak v), \sigma) &\hred (v, \sigma, \epsilon) && \\
    (K[\cbreak v], \sigma) &\hred (\cbreak v, \sigma, \epsilon) && \text{if } K \neq \bullet \text{ and } K \in \pure{\cbreak\!} \\
    (K[\ccontinue], \sigma) &\hred (\ccontinue, \sigma, \epsilon) && \text{if } K \neq \bullet \text{ and } K \in \pure{\ccontinue} \\
\end{aligned}
$$
\caption{Head Reductions for Loop}
\label{fig:hred-loop}
\end{figure}

Figure~\ref{fig:hred-loop} shows the head reduction for $\cloop{e}\!$, $\cbreak\!$, and $\ccontinue$.
\begin{itemize}
\item The first two rules says that when the evaluation of the loop body finishes (must evaluate to the unit) or it encounters a $\ccontinue$, it reset the expression in the hole to $e$, the complete loop body.
\item The third rule says when the loop encounters a $\cbreak\!$ in the hole, the evaluation for the entire loop finishes with the value carried by $\cbreak\!$ as its result.
\item The last two rules says $\cbreak\!$ and $\ccontinue$ can terminate the reduction of their evaluation context $K$, if $K$ is their penetrable context $\text{PenCtx}$ defined as:
$$
\begin{aligned}
    \pure{\cbreak\!} &\triangleq \textit{Cxt}\,\backslash\cloop{e}\!\backslash\ccall \\
    \pure{\ccontinue} &\triangleq \textit{Cxt}\,\backslash\cloop{e}\!\backslash\ccall
\end{aligned}
$$
where $\textit{Cxt}\,\backslash\cloop{e}\!\backslash\ccall\!$ represents the set of contexts without using the $\cloop{e}\!$ and $\ccall\!$ constructs.
This limits effects of $\cbreak\!$ and $\ccontinue$ to stay within the loop body and function body.
We forbid $K$ to be $\bullet$ to avoid infinite reductions.
\end{itemize}

\begin{figure}[h]
$$
\begin{aligned}
    (\ccall v, \sigma) &\hred (v, \sigma, \epsilon) \\
    (\ccall (\creturn v), \sigma) &\hred (v, \sigma, \epsilon) \\
    (K[\creturn v], \sigma) &\hred (\creturn v, \sigma, \epsilon) && \text{if } K \neq \bullet \text{ and } K \in \pure{\creturn\!}
\end{aligned}
$$
\caption{Head Reductions for Function Invocation}
\label{fig:hred-func}
\end{figure}

Figure~\ref{fig:hred-func} shows head reductions for $\ccall\!$ and $\creturn\!$.
\begin{itemize}
\item The first two rules says that when the function body evaluates to a value or a $\creturn\!$ statement, the entire function invocation statement evaluates to the corresponding value.
\item Similar to $\cbreak\!$ and $\ccontinue$, $\creturn\!$ can terminate the evaluation of its penetrable context:
$$
\pure{\creturn\!} \triangleq \textit{Cxt}\,\backslash\ccall
$$
which limits $\creturn\!$ to affect control flow within the innermost $\ccall\!$.
\item The $\creturn v$ itself can not reduce to $v$ outside a function invocation to allow the adequacy theorem hold for our weakest precondition definition, which seems reasonable if we consider any program consists of only an invocation to the main function.
\end{itemize}

\paragraph{Remark.} Notice that there are 4 types of terminals for an expression in the reduction: $v$, $\cbreak v$, $\ccontinue$, and $\creturn v$.
They cannot be further reduced and correspond to 4 different postconditions in the weakest precondition we defined later.
$$
\text{terminals} \triangleq \textit{Val} \cup \{\cbreak v, \ccontinue, \creturn v \sep v \in \textit{Val}\}
$$

\begin{figure}[h]
$$
\begin{aligned}
    (\cif \true \cthen e_2 \celse e_3, \sigma) &\hred (e_2, \sigma, \epsilon) && \\
    (\cif \false \cthen e_2 \celse e_3, \sigma) &\hred (e_3, \sigma, \epsilon) && \\
    (v \cseq e, \sigma) &\hred (e, \sigma, \epsilon) && \\
    (\cfork{e}, \sigma) &\hred ((), \sigma, e) && \text{if $e$ is well-formed} \\
    &\cdots
\end{aligned}
$$
\caption{Head Reductions for Other Expressions}
\label{fig:hred-other}
\end{figure}

Figure~\ref{fig:hred-other} shows the head reduction of the if statement, the sequence statement, and the fork statement.
First three rules are standard, while the last one for fork is modified from the one in the original Iris paper, which requires the expression in the forked thread to be well-formed.
\begin{definition}
    An expression is well-formed iff. every $\cbreak\!$ and $\ccontinue$ in it is scoped by a $\cloop{e}\!$ and every $\creturn\!$ in it is scoped by a $\ccall\!$.    
\end{definition}

% $$
% \begin{aligned}
%     (\cloop{e} (), \sigma) &\hred (\cloop{e} e, \sigma, \epsilon) && \\
%     (\cloop{e} (\cbreak v), \sigma) &\hred (v, \sigma, \epsilon) && \\
%     (\cloop{e} (\ccontinue), \sigma) &\hred (\cloop{e} e, \sigma, \epsilon) &&  \\
%     (K[\cbreak v], \sigma) &\hred (\cbreak v, \sigma, \epsilon) && \text{if } K \neq \bullet \text{ and } K \in \pure{\cbreak\!} \\
%     (K[\ccontinue], \sigma) &\hred (\ccontinue, \sigma, \epsilon) && \text{if } K \neq \bullet \text{ and } K \in \pure{\ccontinue} \\
%     (\ccall v, \sigma) &\hred (v, \sigma, \epsilon) \\
%     (\ccall (\creturn v), \sigma) &\hred (v, \sigma, \epsilon) \\
%     (K[\creturn v], \sigma) &\hred (\creturn v, \sigma, \epsilon) && \text{if } K \neq \bullet \text{ and } K \in \pure{\creturn\!} \\
%     (\cif \true \cthen e_2 \celse e_3, \sigma) &\hred (e_2, \sigma, \epsilon) && \\
%     (\cif \false \cthen e_2 \celse e_3, \sigma) &\hred (e_3, \sigma, \epsilon) && \\
%     (v \cseq e, \sigma) &\hred (e, \sigma, \epsilon) && \\
%     (\cfork{e}, \sigma) &\hred ((), \sigma, e) && \text{if } \wellf{e} \\
%     &\cdots
% \end{aligned}
% $$

% where
% $$
% \begin{aligned}
%     \pure{\cbreak\!} &\triangleq \textit{Cxt}\,\backslash\cloop{e}\!\backslash\ccall \\
%     % \{K \sep \forall K_1, K_2. \text{ if } K = K_1[K_2] \text{ then } K_1 \neq \cloop{e} K_2 \text{ and } K_2 \in \pure{\cbreak\!}\} \\
%     \pure{\ccontinue} &\triangleq \textit{Cxt}\,\backslash\cloop{e}\!\backslash\ccall \\
%     \pure{\creturn\!} &\triangleq \textit{Cxt}\,\backslash\ccall \\
%     % \{K \sep \forall K_1, K_2. \text{ if } K = K_1[K_2] \text{ then } K_1 \neq \cloop{e} K_2 \text{ and } K_2 \in \pure{\ccontinue}\} \\
%     \wellf{e} &\text{ iff. } % TODO: definition of well-definedness
%     \end{aligned}
% $$

% There is a small problem that the expression need to terminate after \cbreak{} and \ccontinue{}, otherwise the evaluation gets stuck.

\section{Weakest Precondition and Proof Rules}

We define the weakest precondition with multiple postconditions for different exit type as follows:
$$
\begin{aligned}
    \wpre{e}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R} \triangleq& \quad
           (e \in \textit{Val} \land \upd \Phi_N(e)) \\
    & \lor (e = \cbreak v \land \upd \Phi_B(v)) \\
    & \lor (e = \ccontinue \land \upd \Phi_C()) \\
    & \lor (e = \creturn v \land \upd \Phi_R(v)) \\
    & \lor \biggl(\forall \sigma. e \notin \text{terminals} \land S(\sigma) \wand \upd \bigl(\cred(e, \sigma) \\
    & \quad \land \later
        \forall e', \sigma', \vec{e}_f. \bigl((e, \sigma) \tred (e', \sigma', \vec{e}_f)\bigr) \wand \upd \\
    & \quad\quad\quad \bigl(S(\sigma') * \wpre{e'}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R} * \varhexstar_{e'\in\vec{e}_f} \wpre{e'}{\top}{\bot}{\bot}{\bot} \bigr)\bigr)\biggr)
\end{aligned}
$$

There are 5 cases in total:
\begin{itemize}
\item \textbf{Normal exit:} If the expression has evaluated to a value, then $\Phi_N$ should hold.
\item \textbf{Break exit:} If the expression has evaluated to $\cbreak\!$, then $\Phi_B$ should hold.
\item \textbf{Continue exit:} If the expression has evaluated to $\ccontinue$, then $\Phi_C$ should hold.
\item \textbf{Return exit:} If the expression has evaluated to $\creturn\!$, then $\Phi_R$ should hold.
\item \textbf{Preservation:} If the expression is a non-terminal, then for any program state, the expression is reducible, and after one step of reduction, the weakest precondition holds for the new expression and any forked thread can terminate normally (where the well-formedness come into effect).
\end{itemize}

% $$
% \cred(e) \triangleq e \notin \textit{Val}\, \cup \{\cbreak v, \ccontinue, \creturn v\}
% $$

% The adequacy theorem will have some problem w.r.t the \creturn statement.

\begin{figure}[h]
    $$
    \begin{aligned}
        \Phi_B(v) &\vdash \wpre{\cbreak v}{\bot}{\Phi_B}{\bot}{\bot} & \textsc{(wp-break)} \\
        \Phi_C() &\vdash \wpre{\ccontinue}{\bot}{\bot}{\Phi_C}{\bot} & \textsc{(wp-continue)} \\
        \Phi_R(v) &\vdash \wpre{\creturn v}{\bot}{\bot}{\bot}{\Phi_R} & \textsc{(wp-return)} \\
        \Box(I \wand{}\, \wpre{e}{\_. I}{\Phi_B}{\_. I}{\Phi_R}) * I &\vdash \wpre{(\cloop{e}e)}{\Phi_B}{\bot}{\bot}{\Phi_R} & \textsc{(wp-loop)} \\
        % \wpre{e}{v. \wpre{K[v]}{\Phi_N}{\Phi_B}{\Phi_C}}{\bot}{\bot} &\vdash \wpre{K[e]}{\Phi_N}{\Phi_B}{\Phi_C} & \textsc{(wp-bind-normal)} \\
        % K\in\pure{\cbreak\!} \land \wpre{e}{\bot}{\Phi_B}{\bot} &\vdash \wpre{K[e]}{\bot}{\Phi_B}{\bot} & \textsc{(wp-bind-break)} \\
        \begin{aligned}
            &(v = \true \wand \wpre{e_2}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R}) \\
            \land &(v = \false \wand \wpre{e_3}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R})
        \end{aligned} &\vdash \wpre{\cif v \cthen e_2 \celse e_3}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R} & \textsc{(wp-if)} \\
        \begin{aligned}
            \texttt{wp}\,e\,& \progspec{\_.\wpre{e_2}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R}} \\
                            & \progspec{\Phi_B}\,\progspec{\Phi_C}\,\progspec{\Phi_R}
        \end{aligned} &\vdash \wpre{e_1 \cseq e_2}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R} & \textsc{(wp-seq)} \\
        \wpre{e}{\Phi_N}{\bot}{\bot}{\Phi_R} &\vdash \wpre{\ccall e}{\Phi_N \lor \Phi_R}{\bot}{\bot}{\bot} & \textsc{(wp-call)} \\
        \begin{aligned}
            \texttt{wp}\,e\,& \progspec{v. \wpre{K[v]}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R}} \\
                            & \progspec{v. K \in \pure{\cbreak\!} \land \Phi_B(v)} \\
                            & \progspec{v. K \in \pure{\ccontinue} \land \Phi_C(v)} \\
                            & \progspec{v. K \in \pure{\creturn\!} \land \Phi_R(v)}
        \end{aligned} &\vdash \wpre{K[e]}{\Phi_N}{\Phi_B}{\Phi_C}{\Phi_R} & \textsc{(wp-bind)} \\
        &\cdots
    \end{aligned}
    $$
    \caption{Some Rules for Weakest Precondition}
    \label{fig:wp-rules}
\end{figure}

Figure~\ref{fig:wp-rules} shows some rules derivable from our definition of the weakest precondition, which we have proved informally and should hold if formalized in Coq using Iris.
We mainly demonstrate rules related to the control flow and binding.

\begin{itemize}
    \item The first three rules, \textsc{wp-break}, \textsc{wp-continue}, and \textsc{wp-return}, are rules for three primitives to manipulate control flow.
    \item The \textsc{wp-loop} is the standard loop rule involving loop invariant.
    The \textsc{wp-if} and \textsc{wp-seq} are also standard rules for if statement and sequence statement with multiple exit conditions.
    \item The \textsc{wp-call} allows conversion from return postconditions to normal postconditions upon the completion of function invocation.
    \item The most interesting rule is the \textsc{wp-bind} rule, which is the main obstacle in the previous effort to equip Iris with control flow.
    In the weakest precondition of inner expression $e$, the normal postconditions is simply the weakest precondition for the remaining context $K$.
    The postconditions for other exit kind is more interesting. Taking $\cbreak\!$ for example, the postcondition says the remaining context $K$ is penetrable by $\cbreak\!$ and the overall break condition $\Phi_B$ holds. \begin{itemize}
        \item If $K$ is penetrable, then the $\cbreak\!$ inside $e$ can also break the control flow in $K$. Thus the break postconditions of $e$ and $K[e]$ should be the same.
        \item If $K$ is impenetrable, then the $\cbreak\!$ inside $e$ is scoped by some $\cloop{e}\!$ in $K$. Therefore, we should forbid the break condition of $e$ to affect the break condition of $K[e]$ (which is determined by statements outside the $\cloop{e}\!$ in $K$) by evaluating $K \in \pure{\cbreak\!}$ and entire break condition to $\bot$.
        \item In the second case, to consider the break condition of $e$ properly, we should use \textsc{wp-bind} to bind the context outside the loop and apply \textsc{wp-loop} to the entire loop containing $e$.
    \end{itemize}
\end{itemize}

% Return conditions should be merged with normal conditions upon calling the function.

\section{Typing}

We also think of the possible typing system of the language consisting of following primary types.
$$
A, B \in \textit{Type} ::= \tau \sep \tunit \sep \tint \sep \tbool \sep A \rightarrow B \sep \cdots
$$
With multiple control flow exits, we should type the result of all possible exits for an expression.
The $\tau$ represents any type, and if some exit is impossible for an expression (e.g. normal exit for $\cbreak\!$), we should type the result of corresponding exit as $\tau$.
It has the following property:
$$
\forall A \in \textit{Type}. \tau = A
$$

\subparagraph{Syntactic Typing}

$$
    \Gamma \vdash e: A_N, A_B, A_C, A_R
$$

\begin{mathpar}
    \inferrule*[left=type-break]{
        \Gamma \vdash e: A_N, A_B, A_C, A_R
    }{
        \Gamma \vdash \cbreak e: \epsilon, A_N + A_B, A_C, A_R
    }
    \and
    \inferrule*[left=type-continue]{}{
        \Gamma \vdash \ccontinue: \epsilon, \epsilon, \tunit, \epsilon
    }
    \and
    \inferrule*[left=type-return]{
        \Gamma \vdash e: A_N, A_B, A_C, A_R
    }{
        \Gamma \vdash \creturn e: \epsilon, A_B, A_C, A_N + A_R
    }
    \and
    \inferrule*[left=type-loop]{
        \Gamma \vdash e: \tunit, A_B, \tunit, A_R
    }{
        \Gamma \vdash \cloop{e} e: A_B, \epsilon, \epsilon, A_R
    }
    \and
    \inferrule*[left=type-apply]{
        \Gamma \vdash e_1: A_N \rightarrow (A_N', A_B', A_C', A_R') \and
        \Gamma \vdash e_2: A_N, A_B, A_C, A_R
    }{
        \Gamma \vdash e_1(e_2): A_N', A_B + A_B', A_C + A_C', A_R + A_R'
    }
\end{mathpar}

where

$$
\begin{aligned}
    A + B &\triangleq \begin{cases}
        A & \text{if } B = \epsilon \text{ or } A = B \\
        B & \text{if } A = \epsilon \text{ or } A = B \\
        \text{undefined} & \text{otherwise}
    \end{cases} \\
    A \rightarrow (B_1, B_2, \cdots) &\triangleq A \rightarrow B_1, A \rightarrow B_2, \cdots
\end{aligned}
$$

\subparagraph{Semantic Typing}

$$
\Gamma \vDash e: A_N, A_B, A_C, A_R \triangleq \Gamma \vDash \htriple{\text{True}}{e}{\vtype{A_N}}{\vtype{A_B}}{\vtype{A_C}}{\vtype{A_R}}
$$

\end{document}