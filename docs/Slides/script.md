大家好，今天我来介绍一下我Iris-CF的工作。
这是一个基于Iris程序逻辑的支持控制流的逻辑。

接下来我会先简单介绍一下Iris程序逻辑的框架和为什么需要Iris-CF这个工作。
然后介绍我们是如何设计我们的程序语言的。
然后我们先看一下在Iris中，原来的程序逻辑是什么样子的，以及我们如何扩展Iris使其支持控制流的验证。
最后我们将Iris-CF和现有的基于continuation的Iris逻辑进行对比来作为总结。

首先我们来看一下什么是Iris框架。
iris是一个高阶并发分离逻辑框架，他在coq中实现和验证。
iris逻辑有base logic和program logic两部分组成。
base logic是iris设计的一套高阶分离逻辑，他是assertion logic，在这个assertion logic之上iris来定义他们的程序逻辑。
在iris中，他们的霍尔三元组和之后看到的最弱前条件全是assertion，都是直接有assertion logic定义得到的。
用户可以提供某个特定的程序语言，iris可以利用这个语言的某些性质生成对应的程序逻辑，并提供一些基础的性质，用户可以在这之上对其程序逻辑证明更实际的证明规则。
我们也是先给出一个带控制流的程序语言，再来定义我们的程序逻辑的。

Iris本身是不支持控制流的，他的程序语言里就没有设计break之类的语句。
一种方式是用continuation来模拟控制流，我们在最后再来看这种方式。

我们希望的是可以用VST中那种带多个后条件的断言来描述控制流。
以这条顺序执行规则为例。
他的结论说的是从满足P的程序状态出发，顺序执行e1e2，如果其正常终止，那么终止程序状态满足Q，如果其break终止、continue终止、return终止，对应的程序状态要满足对应的后条件。

接下来我们来看一下我们设计的程序语言是什么样的。

Iris的程序逻辑是针对lambda calculus这种函数式编程语言设计的，我们的程序语言自然也是函数式编程语言。
我们定义它的常数表达式如下，包括unit，整数，布尔值，地址l，还有lambda表达式。
该语言的表达式包括了Iris原来语言的大部分内容，包括常数表达式，变量，lambda函数调用这些基本的表达式……

我们主要来看一下我们新增的内容。
蓝色部分是我们新增的循环和break，continue语句。
循环本身可以用递归的lambda函数定义，但是为了能用控制流改变执行我们定义了一个构造子。
他的下标e表示完整的循环体，第二个e表示当前一轮迭代中剩余未执行完的表达式。

为了更好的理解这种定义，我们先来看一下循环语句的context定义。
在lambda calculus里，有context这种东西，它规定了一个表达式中每个子表达式的执行顺序。
对于一个表达式，我们可以把它拆成一个context和另一个子表达式的组合，并且每一步的拆解都是唯一的。

以循环的context为例……

对于函数的控制流，我们将函数调用和lambda函数调用进行区分，lambda函数调用是不约束return控制流，只有显示的加上call标签的才会约束return。

以阶乘函数为例，我们用lambda calculus里比较经典的方式定义这种递归函数，不过我们在每次函数调用前都加上call……

我们给函数调用也定义其对应的context。

我们接着来看一下这个语言的小步语义是如何定义的。
这个(->h)说的是……
下面的thread local reduction说的是一个完整的程序的化简步骤，他是把一个程序拆成一个大的context和一个最原子的表达式，这个表达式的一步化简定义了整个程序的一步化简。

对于循环，如果……

如果循环体化简成了break……

对于break和continue来说，如果其外层的context是可以被击穿的，那么我们可以一步跳过这层context。
这里可击穿的context都是深度为1的，对于break和continue，他们不能击穿loop和call。
可以看出，一个循环体最终总是会化简成常数、break、continue三者之一，然后根据上面三条化简规则进一步化简。

对于函数调用，其语义也是类似的，唯一的不同是return可以击穿loop。

接下来我们来看一下Iris中的程序逻辑是什么样的。

通常，我们用一个霍尔三元组来表示关于程序的断言，他说的是如果从满足P的程序状态出发，执行e后得到其结果为v，那么终止程序状态要满足Q(v)。
在Iris中，他是用最弱前条件作为其程序断言的。
WP是一个assertion，对于任意程序状态，如果从它执行e可以得到满足Q(v)的程序状态，那么他就在最弱前条件中。
显然，霍尔三元组可以这样有WP定义得到，其前条件必须是WP的一个子集。

Iris的WP是在他的assertion logic中定义的，所以我们用wand来表示蕴含关系。
这里的box说的是这个assertion在任何程序状态上永远都是成立的，也就是说，我不需要任何其它多余的heap，只要给我P，我就能推出e的WP。

Iris中WP是这样定义的。
他说的是如果e已经化简完了是个常数，那么后条件就要成立。
否则，e在sigma上必须可以继续化简，而且化简之后WP还要可以保持。

我们来看一下在Iris中如何证明一个程序的正确性。
假设我们要证明这个结论。

我们先使用蓝色部分所示的结合规则。
他说的是我们可以证明执行内层表达式后我们可以满足外层的WP，从而证明原来的WP。
对于内层表达式e，如果它是一个原子的表达式，我们用其对应的证明规则直接证明，然后用consequence rule建立后条件之间的联系。

我们对于WP的定义做一定修改就得到了多个后条件的WP……

接着我们来看一下在这个定义下有哪些可以用的证明规则。
首先，是对于三种控制流语句的基本性质。

然后比较关键的一条性质是循环规则。
这是VST中的循环规则，他说的是……

对应的Iris-CF中的规则其实就是把triple按WP的定义展开。

函数调用规则也是比较直观的，函数体不能break，continue终止……

在Iris中最关键的一条规则是结合规则……

在Iris-CF中，我们有如下一条结合规则。
关于e的WP中，其正常终止条件比较直观，但是三个控制流后条件比较特殊，我们额外要求K是对应的可击穿context。  

以break为例，如果
- e break, K pen
- e break, K impen
- e not break
如果蓝色部分不被满足，那么我们应该使用其它证明规则。

顺序执行规则其实可以由结合规则直接导出。

在总结之前，我们看一下结合规则在triple下的证明规则。
这里关于e的证明和关于K的证明其实是完全分离的，在证明e的triple的时候，我们完全不需要考虑K对其的影响。
这种我们称之为contextual local性质，它对模块化的证明是非常有利的。

我们的成果就是……

在之前提到的continuation的方法中，我们引入这样一种表达式来记录外层的context方便之后break一类的控制流执行。
在需要break的时候，我们使用throw指令直接将整个程序修改成之前记录的context继续执行。
这里的K'一开始是x，在call/cc的时候被替换掉成了外层的context。
对应的我们有这样一条证明规则，要证明原来的程序，我们只要证明把所有这种控制流后续的context替换之后的程序就可以了。
这里不是contextual local的，因为我们实际证明内层循环的时候已经看到了外层context，我们需要对整体的程序，甚至是与内层e无关的部分，都要有一个事先的spec。